# Forked - Codeforces 1904A

- **URL:** http://codeforces.com/contest/1904/problem/A

- **Objective:**

  1. infinite chess board. 
  2. positions of king and queen are given. 
  3. find the number of positions in which a knight can be placed, so that king and queen are forked.
  4. knight is not standard, meaning it can move 'a' tiles in x and 'b' tiles in y directions

- **Constraints:**

  1. 1 <= a, b <= 10^8 
  2. 0 <= xk, yk <= 10^8
  3. 0 <= xq, yq <= 10^8

### Solution 1 - Brute Force

1. Intuition
    1. Instead of making the problem complex by assuming the knight to be at (x, y) and check for all the possibilities, which leads to solving equations; we can reverse engineer.
    2. Think of the king itself as a knight and find all the positions to which king can move, which is easy to calculate because we already know the king's original position.
    3. Similarily, we do that for the queen.
    4. Now, the common points between these possible locations tells us that if a knight is placed there, it is a fork !!
1. Time Complexity - O(1)
    1. there are only 8 possibilities at max for each king and queen (less if a == b or a = 0 or b == 0)
    2. for every possible location of a queen, we search for the same point in king's possible locations, that 8 * 8 at max, which O(64) ~ O(1)
2. Space Complexity - O(1) 
    1. we use some space to store the points, but it is still constant. 


```python
def solve(a, b, xk, yk, xq, yq):

    # points - change of x, change of y from the current position
    # these 8 (dx, dy) are the only possibilities. 
    # if the current position of a knight is (x, y)
    # it can only move to (x + dx, y + dy)

    # this is a set because, if a == b or a == 0 or b == 0
    # there will be duplicates and we will be counting more than once.
    points = {
        (+a, +b),
        (+a, -b),
        (+b, +a),
        (+b, -a),
        (-a, +b),
        (-a, -b),
        (-b, +a),
        (-b, -a),
    }

    # all the places that king can move if king itself acts as a knight
    # and find the common points between the kings moves and queens moves

    # this can be done using sets too, but sets have an overhead of hashing
    # but it does not matter in this case as we have only <= 8 possibilities
    k_moves, q_moves = [], []
    for dx, dy in points:
        k_moves.append((xk + dx, yk + dy))
        q_moves.append((xq + dx, yq + dy))

    return sum((xq + dx, yq + dy) in k_moves for dx, dy in points)

    
for _ in range(int(input())):
    a, b = map(int, input().split())
    xk, yk = map(int, input().split())
    xq, yq = map(int, input().split())
    print(solve(a, b, xk, yk, xq, yq))
```

### Further Analysis
### Problem Variations

### Points to Remember
1. Instead of complicating the problem, for few problems we should be thinking of reverse engineering.
2. Be careful not to count duplicates when a == b or a == 0 or b == 0