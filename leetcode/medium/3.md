# Longest Substring without repeating characters - Leetcode 3

- **URL:** https://leetcode.com/problems/longest-substring-without-repeating-characters/description

- **Objective:**

  1. given a string `s`, find the length of the longest substring without duplicate characters.

- **Constraints:**

  1. 0 <= len(s) <= 5 * 10^4 -> empty strings are possible
  2. `s` consists of
        1. letters (lowercase + uppercase)
        2. digits 
        3. symbols 
        4. spaces -> so blank strings are possible

- **Tags:** string, sliding-window

---

### Solution 1: BruteForce

1.  **Intuition:**
    1. check every substring if it is valid, i.e has no duplicate characters. 
2.  **Time Complexity:** upper bound O(n^3)
    - two loops for substrings + inner loop to validate the substring
3.  **Space Complexity:** O(min(n, character set size)). 
    - character size can be 128 / 256 based on the ASCII set that is used.

```python
def solve(s):
    def is_valid(i, j):
        chars = set()
        for k in range(i, j+1):
            if s[k] in chars:
                return False
            chars.add(s[k])
        return True

    n = len(s)
    maxl = 0
    for i in range(n):
        for j in range(i, n):
            if is_valid(i, j):
                maxl = max(maxl, j-i+1)
    return maxl
```

---

### Solution 2: Sliding window + set

1.  **Intuition:**
    1. instead of picking every substring as in Solution 1, we maintain the characters of current substring between the range [l, r] in a set.
    2. If we encounter a duplicate character, we start shrinking the sliding window from left until the current character is removed from the window and therefore, not a duplicate anymore. This step is making the window valid again. We then add the current character into the window.
2.  **Time Complexity:** O(2 * n) ~ O(n) -> atmost each character is visted twice. Imagine the last two characters are same, we now have to shrink the whole window (which contains everything from start) till the current character.
3.  **Space Complexity:** O(min(n, character set size))

```python
def solve(s):
    n = len(s)
    window = set()
    l = 0
    maxl = 0
    for r in range(n):
        while s[r] in window:
            window.remove(s[l])
            l += 1
        window.add(s[r])
        maxl = max(maxl, r-l+1)
    return maxl
```

---

### Solution 3: Sliding Window + Hashmap

1.  **Intuition:**
    1. this is similar to Solution 2, but instead of a set, we use a hashmap to store # character: last_known_index
    2. Becareful while updating the left / start of the sliding window, because we are not removing the characters anymore (like in Solution 2), we might encounter some character that is not present in the range s[l:r+1], but still present in the map. 
    3. Consider the example "abba", once the second "b" is encountered, we change the `l` to index_of[first_b]+1, but observe that we did not remove the letter "a" from the map. So, when we reach the second "a", the window still says that another "a" is present and `l` would be updated to index_of[first_a], this causes the sliding window to expand again, which is wrong. so we cap the start of the sliding window `l` to always choose the maximum.  
2.  **Time Complexity:** O(n)
    - each letter is processed only once.
3.  **Space Complexity:** O(min(n, character set size))

```python
def solve(s):
    n = len(s)
    window = {}
    l = 0
    maxl = 0
    for r in range(n):
        if s[r] in window:
            l = max(l, window[s[r]]+1)
        maxl = max(maxl, r-l+1)
        window[s[r]] = r
    return maxl
```

### Solution 4: Array to store the index of the character

1.  **Intuition:**
    1. Because we know the character set, instead of a hashmap to store the index, we store them in an array.
    2. Because we store in an array, there is no overhead of hashing.
2.  **Time Complexity:** O(n)
3.  **Space Complexity:** O(1) 
    - this is treated as constant because it does not change with the input. 
```python
def solve(s):
    n = len(s)
    last_index = [-1] * 128
    l = 0
    maxl = 0

    for r in range(n):
        if last_index[ord(s[r])] != -1:
            l = max(l, last_index[ord(s[r])]+1)
        maxl = max(maxl, r-l+1)
        last_index[ord([s[r]])] = r
    return maxl
```

---

### Further Analysis

- **Edge Cases:**

  1.  the problem states that, `s` can contain letters, digits, symbols and spaces. we cannot simply use a 26 sized array to store the indexes of the letters.
```
"" empty string -> output = 0 
" " one space -> output = 1
"  " two spaces -> output = 1
```

- **Problem Variations:**
  1. [what if there can be atmost k distinct characters ? In this problem, we need to make sure everything is unique, but in this variation duplication is allowed.](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/description/)
  2. [Same as above but k = 2 always](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/description/)

---

### Points to Remember

1. Time complexity of `Set` in python, 
```
Set, Dictionaries in python are implemented as HashTables.

Average Time complexity (amortized)
add(x): O(1)
remove(x): O(1)
x in set: O(1)
len(set): O(1)

if many keys hash to the same bucket (hash collisions), they can degrade to O(n) because of rehashing and shifting things, the set will be automatically resized when load factor gets high.
```
