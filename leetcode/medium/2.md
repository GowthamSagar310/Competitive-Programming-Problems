# Add Two Numbers - Leetcode 2

- **URL:** https://leetcode.com/problems/add-two-numbers/description/

- **Objective:**

  1. two non-empty linked lists (lengths might be different) represent two non-negative integers.
  2. they are given in the order of last digit to the first digit
  3. we need to add them in the same order.
  4. the resultant should also be in the reverse order, that is last digit to the first digit.
 
- **Constraints:**

  1. 1 <= number of nodes <= 100
  2. 0 <= node.val <= 9
  3. no leading zeroes

- **Tags:** linked-list

---

### Solution 1: BruteForce

1.  **Intuition:**
    1. the lists are given in reverse order, so there is no problem in adding them, we add corresponding nodes, while maintaining the carry. 
    2. the sum of two nodes cannot exceed 18, as the max value of a node is 9 (given), so the carry will always be either 0 or 1
2.  **Time Complexity:** O(N1 + N2)
3.  **Space Complexity:** O(N1 + N2)

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:

    dummy = ListNode(-1)
    head = dummy
    carry = 0
    while l1 or l2 or carry:
        d1 = l1.val if l1 else 0 
        d2 = l2.val if l2 else 0
        total = d1 + d2 + carry
        dummy.next = ListNode(total % 10)
        carry = total // 10
        dummy = dummy.next
        if l1: l1 = l1.next 
        if l2: l2 = l2.next

    return head.next
```

---

### Further Analysis

- **Edge Cases:**

    1. observe the lengths can be different.
    2. the other way to write code for this problem would be to, process the first while loop only when both the list elements are present and then write separate loops for l1 and l2. 

- **Problem Variations:**
  1. What if there are leading zeroes ? 
  2. What if the lists are given as a regular number (first digit to last digit) ? 
    - we can reverse the lists first and then solve the same way
    - we can use stacks to simulate reversal
  3. what if there are negatives ? 
  4. what if the question to multiple the numbers ?

---

### Points to Remember

1. In most of problems involving linkedlists, it helps to maintain a dummy node to start with to avoid head null cases. In this way, we can assume head is always initialized and at the end, we can just return dummy.next
```python
dummy = ListNode(-1)
head = dummy
...
...
return head.next
```
2.  Similarily in linkedlist problems, it helps to just solve the edges cases first, i.e, head null cases, only one node cases etc. because they involving updating the pointers and there will lot of `.next` cases. By solving the edges cases first, we dont have to write lot of if checks for the null cases.