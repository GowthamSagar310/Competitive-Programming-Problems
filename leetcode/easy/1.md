# Two Sum - Leetcode 1

- URL https://leetcode.com/problems/two-sum/description/
- Objective:
  1. find `pair of elements` that `add` up to a `target`.
  2. one solution is guaranteed.
  3. return indices in any order.
- Constraints:
  1. 2 <= nums <= 10^4
  2. -10^9 <= nums[i], target <= 10^9
- Tags: hashmap

### Solution 1 - Brute Force

1. Time Complexity - O(n ^ 2)
2. Space Complexity - O(n)

```python
def solve(nums):
  n = len(nums)
  for i in range(n):
      for j in range(i+1, n):
          if nums[i] + nums[j] == target:
              return [i, j]
```

### Solution 2 - Hashmap (single loop)

1. Time Complexity - O(n)
2. Space Complexity - O(n)

```python
def solve(nums):
  n = len(nums)
  m = {}
  for i in range(n):
      if target-nums[i] in m:
          return [i, m[target-nums[i]]]
      m[nums[i]] = i
  return [] # just safety. question stated that solution is guaranteed
```

### Solution 3 - Sort + Binary search for each value

### Solution 4 - Sort + Two pointers (one on left, one of right)

1. Time Complexity: O(nlogn) for sorting + O(n) for two pointer iteration
2. Space Complexity: O(n) because indices information must be stored before sorting.

### Further Analysis

1. what if the target is sum of duplicates ?

   1. I actually got myself asked a variation of this question, where I encountered this problem. for example, 8 = 4+4, 2 = 1+1

   2. the problem does not arise in a single pass solution because we are checking the needed value first and then adding it to the map.

      > [1, 2, 2] target = 4 <br>
      > when we are at the last 2, the map contains only the previous 2 and not the last one, so there is no duplicate case here.

   3. the problem is with when we first iterate through the nums, store indices in hashmap and then iterate through the nums again. as hashmap wont allow duplicate keys
      > [1, 2, 2] map = {1: 0, 2:1} <br>
      > here map contains only one 2, so when going through the nums again to find pairs,
      > we need to also check if, the needed value is not the value that we are currently at. i.e needed_value_index != current_index

### Problem Variations

1.  [How would the solution change if we needed to find **all** possible pairs instead of just one?]
2.  [What if the input was a stream of numbers instead of a static array?]
3.  [How would the problem change if it was **Three Sum** or **K Sum**?]

### Points to Remember

1. Hashing helps find things quickly. trade space for speed.
1. **Trade-offs:** [General principle learned, e.g., "Using a hash map is a classic space-for-time trade-off. It improves time complexity from O(nÂ²) to O(n) at the cost of O(n) space."]
1. **Pattern Recognition:** [Identify the underlying pattern, e.g., "When you need to find a pair of elements that satisfy a certain condition, a hash map is an extremely effective tool for O(1) lookups."]
1. **Data Structure Choice:** [Why a specific data structure was chosen, e.g., "A hash map (or dictionary in Python) is ideal because it stores key-value pairs, allowing us to associate a number with its original index."]
